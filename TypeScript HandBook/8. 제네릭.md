#### Hello World 제네릭

```typeScript
function identity(arg: number): number {
    return arg;
}
```

- 제네릭이 없으니, identity 함수에 특정 타입을 주거나, any 타입을 이용 해야 한다.

```typeScript
function identity(arg: any): any {
    return arg;
}
```
> any를 쓰는 것은 함수의 arg 가 어떤 타입이든 받을 수 있다는 점에서, 제네릭과 유사하지만, 실제로 함수가  
  반환될 때, 어떤 타입인지에 대한 정보는 잃게 된다. number 타입을 넘긴다고 해도 any 타입이 반환된다는 정보만  
  얻을 뿐이다.
  
- 무엇이 반환되는지 표시하기 위해, 인수의 타입을 값이 아닌 타입 변수를 사용한다.

```typeScript
function identity<T>(arg: T): T {
    return arg;
}
```
> T 라는 타입 변수를 추가했다.


- 제네릭 함수를 작성하고 나면, 두 가지 방법 중 하나로 호출 할 수 있다.  
  첫번째 방법은 함수에 타입 인수를 포함한 모든 인수를 전달하는 방법이다.
  
```typeScript
let output = identity<string>("myString"); // 출력 타입은 'string' 이다.
```

- 두번째 방법은 타입 인수 추론을 사용하는 것이다. 즉, 우리가 전달하는 인수에 따라서 컴파일러가  
  T 의 값을 자동으로 정하게 하는 것이다.
  
```typeScript
let output = identity("myString"); // 출력 타입은 'string' 이다.
```
> 인수 추론은 코드가 간결하고 가독성 있게 하지만, 복잡한 예제에서 컴파일러가 유추할 수 없는 경우,  
  명시적인 타입 인수 전달이 필요할 수도 있다.
  
  
***


#### 제네릭 타입 변수 작업 (Working with Generic Type Variables)

- 제네릭을 사용하면, 제네릭 함수를 만들 때 컴파일러가 함수 본문에 제네릭 타입화된 매개변수를 쓰도록  
  강요한다. 즉, 이 매개변수들 실제로 any 나 모든 타입이 될 수 있는 것처럼 취급할 수 있게 된다.
  
```typeScript
function identity<T>(arg: T): T {
    return arg;
}
```

>> 함수 호출 시마다 arg 의 길이를 로그에 찍으려면 이렇게 하게 될것이다.

```typeScript
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length): // 오류: T에는 .length 가 없습니다.
    return arg;
}
```

- 어떤 곳에서도 arg 가 length 라는 멤버가 있다는 것이 명시되어 있지않아, 함수 사용자가 .length 멤버가 없는  
  number 를 대신 전달할 수도 있다.
  
```typeScript
function loggingIdentity<T>(arg: T[]): T[] {
  console.log(arg.length); // 배열은 .length를 가지고 있습니다. 따라서 오류는 없습니다.
  return arg;
}
```
  
  
  
  
