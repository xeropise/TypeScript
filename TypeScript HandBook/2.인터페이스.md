#### 소개

- 타입스크립트의 핵심 원칙 중 하나는 타입 검사가 값의 "형태" 에 초점을 맞추고 있다는 것  
- "덕 타이핑(duck typing)" 혹은 "구조적 서브타이핑(structural subtyping)"  
- 이러한 타입들의 이름을 짓는 역할 및 코드 안의 계약을 정의하는 가장 강력한 방법임.

#### 첫 번째 인터페이스 (Our First Interface)


```typeScript
function printLabel(labeledObj: { label: string }) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```
> 매개변수로 삽입되는 객체가 실제로는 더 많은 프로퍼티를 갖고 있지만, 컴파일러는 최소한의 필요한 프로퍼티가  
  있는지 타입이 잘 맞는지만 검사한다. 
  
***

```typeScript
interface LabeledValue {
    label: string;
}

function printLabel(labledObj: LabledValue) {
    console.log(labeledObj
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

> 위 아래 예제는 동일하게 작동한다, 타입 검사는 프로퍼티들의 순서를 요구하지 않는다,  
  단지 인터페이스가 요구하는 프로퍼티들이 존재하는지, 요구하는 타입을 가졌는지만 확인한다.
  
***

#### 선택적 프로퍼티 (Optional Properties)

- 인터페이스의 모든 프로퍼티가 필요한 것은 아니어서, 몇개의 프로퍼티만 채워 전달 하도록 함.  
- 프로퍼티 선언에서 이름 끝에  ? 를 붙여 표시  
- 인터페이스에 속하지 않는 프로퍼티의 사용을 방지하면서, 사용 가능한 속성을 기술  

```typeScript
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    
    if(config.width) {
        newSquare.area = config.width * config.width;
    }
    
    if(config.clor) {
      // Error: Property 'clor' does not exist on type 'SquareConfig'
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
```
>  프로퍼티 이름을 잘못 입력하면, 오류 메시지로 알려 준다.

***

#### 읽기전용 프로퍼티 (Readonly properties)

- 일부 프로퍼티들은 객체가 처음 생성될 때만 수정 가능해야 한다.  
  프로퍼티 이름 앞에 readonly 를 넣어서 이를 지정할 수 있다.
  
```typeScript
interface Point {
    readonly x: number;
    readonly y: number;
}
```

```typeScript
let p1: Point = { x:10, y:20 };
p1.x = 5; // 오류!
```
> 할당 후에는 x, y를 수정할 수 없다.


```typeScript
let a: number[] = [1,2,3,4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // 오류 !
ro.push(5) // 오류 !
ro.length = 100; // 오류 !
a = ro; // 오류 !
```
> 모든 변경 메서드(Mutating Methods)가 제거된 Array<T>와 동일한 ReadonlyArray<T> 타입을 제공한다.  
  생성 후에 배열을 변경하지 않음을 보장할 수 있다.
   
```typeScript
a = ro as number[]'
```
> 타입 단언(type assertion)으로 오버라이드하는 것은 가능하다.
