#### 소개

- 자바스크립트는 재사용할 수 있는 컴포넌트를 만들기 위해 함수와 [프로토타입-기반 상속](https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67)을 사용했지만, 객체 지향 접근 방식에 익숙한 프로그래머 입장에서는 다소 어색할 수 있다.  

- ECMAScript 2015 (ECMAScript 6) 를 시작으로, 객체-지향적 클래스-기반의 접근 방식을 사용해서 어플리케이션 생성 가능  

#### 클래스 (Classes)

```typeScript
class Greeter {
   greeting: string; 
   constructor(message: string) {
      this.greeting = message;
   }
   greet() {
      return "Hello, " + this.greeting;
   }
}

let greeter = new Greeter("world");
```

***

#### 상속 (Inheritance)


```typeScript
class Animal {
    move(distanceMeters: number = 0) {
      console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog Extends Animal {
    bark() {
       console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
```
> Dog는 extends 를 사용하여 Animal 이라는 상위 클래스(_superclasses_) 로부터 생겨난, 하위 클래스(_subclasses_) 이다.




```typeScript
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
```

> 서브 클래스의 생성자 함수는 상위 클래스의 생성자 함수를 실행할 super() 를 호출해야 한다.    
  생성자 내에서 this 에 있는 프로퍼티에 접근하기 전에 super() 를 먼저 호출 해야 한다.  
  상위 클래스의 메서드를 하위 클래스에 특화된 메서드로 오버라이드 하는 것을 확인 가능


#### public, private 그리고 protected 지정자 ( public, private, and protected modifiers)

