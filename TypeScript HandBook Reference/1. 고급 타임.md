#### 교차 타입 (Intersection Types)

- 여러 타입을 하나로 결합한 것을 말한다. 기존 타입을 합쳐, 필요한 모든 기능을 가진 하나의 타입을 만들 수 있다.

- '&' 을 사용

```typeScript
function extend<First, Second>(first: First, second: Second): First & Second {
    const result: Partial<First & Second>  = {}' 
    for (const prop in first) {
        if (first.hasOwnProperty(prop)) {
            (result as First)[prop] = first[prop];
        }
    }
    for (const prop in second) {
        if (second.hasOwnProperty(prop)) {
            (result as Second)[prop] = second[prop];
        }
    
    }
    return result as First & Second;
}

class Person {
    constructor(public name: string) { }
}

interface Loggable {
    log(name: string): void;
}

class ConsoleLogger implements Loggable {
    log(name) {
          console.log(`Hello, I'm ${name}.`);
    }
}

const jim = extend(new Person('Jim'), ConsoleLogger.prototype);
jim.log(jim.name);
```


***


#### 유니언 타입 (Union Types)

- 교차 타입과 밀접하게 관련되어 있지만, 매우 다르게 사용된다. 가끔 숫자나 문자열을 매개변수로 기대하는 라이브러리르 사용할 때가 있는데,
  다음이 그 예다.
  
```typeScript
/**
 *  문자열을 받고 왼쪽에 "padding"을 추가합니다.
 *  만약 'padding'이 문자열이라면, 'padding'은 왼쪽에 더해질 것
 *  만약 'padding'이 숫자라면, 그 숫자만큼의 공백이 왼쪽에 더해질 것
 */ 
function padLeft(value: string, padding: any) {
    if (typeof padding === "number" ) {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string" ) {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}

padLeft("Hello world", 4); // "    Hello world"를 반환합니다.
```

- padLeft 의 문제는 매개변수 padding 이 any 타입으로 되어 있다는 것이다.  
  즉 숫자나 문자열 둘 다 아닌 인수로 호출할 수 있다는 것이다.

```typeScript
let indentedString = padLeft("Hello world", true); // 컴파일 타임에 통과되고, 런타임에 오류.
```

- any 대신에 세로 막대 ( | ) 를 사용하여 유니언 타입을 매개변수에 사용할 수 있다.

```typeScript
/**
 * 문자열을 받고 왼쪽에 "padding"을 추가합니다.
 * 만약 'padding'이 문자열이라면, 'padding'은 왼쪽에 더해질 것입니다.
 * 만약 'padding'이 숫자라면, 그 숫자만큼의 공백이 왼쪽에 더해질 것입니다.
 */
function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft("Hello world", true); // 컴파일 중에 오류
```

- 유니언 타입을 값으로 가지고 있으면, 유니언에 있는 모든 타입에 공통인 멤버에만 접근할 수 있다.

```typeScript
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ..
}

let pet = getSmallPet();
pet.layEggs();    // 성공
pet.swim();       // 오류 
```


***


#### 타입 가드와 차별 타입 (Type Guards and Differentiating Types)

- 유니언 타입에서 어떤 타입인지 구체적으로 알고 싶으면, 분기 처리를 하여 검사 하게되는데 오류 발생

```typeScript
let pet = getSmallPet();

// 이렇게 각 프로퍼티들에 접근하는 것은 오류를 발생시키낟.

if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}
```

- 같은 코드를 동작하게 하려면, 타입 단언을 사용해야 한다.

```typeScript
let pet = getSmallPet();

if ((pet as Fish).swim) {
    (pet as Fish).swim();
} else if ((pet as Bird).fly) {
    (pet as Bird).fly();
}
```


***


#### 사용자-정의 타입 가드 (User-Defined Type Guards)

- 위의 예제는 타입 단언을 여러번 사용했는데, 검사를 실시 했을 때, 각 타입을 알 수 있다면 훨씬 좋을 것이다.

- 타입 가드는 스코프 안에서 타입을 보장하는 런타임 검사를 수행한다는 표현식이다


***


#### 타입 서술어 사용하기 (Using type predicates)

- 타입 가드를 정의하기 위해, 반환 타입이 타입 서술어인 함수를 정의만 하면 된다.

```typeScript
function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}
```
> pet is Fish 는 타입 서술어

- 타입 서술어는 'parameter is Type' 형태이고, 반드시 현재 함수 시그니처의 매개변수 이름이어야 한다.

- isFish 가 변수와 함께 호출될 때마다, TypeScript는 기존 타입과 호환된다면 그 변수를 특정 타입으로 제한할 것이다.

```typeScript
// 이제 'swim'과 'fly'에 대한 모든 호출은 허용됩니다

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
```

- 타입스크립트는 pet 이 if 문 안에서 Fish 라는 것을 알고 있을뿐만 아니라, else 문 안에서 Fish 가 없다는 것을 알고 있으므로,
   Bird 를 반드시 가지고 있어야 한다.
   
 
***


#### in 연산자 사용하기 (Using the in operator)

- in 연산자는 타입을 좁히는 표현으로 작용

- 'n in x' 표현에서, n 은 문자열 리터럴 혹은 문자열 리터럴 타입이고, x 는 유니언 타입이다.

- "true" 분기에서는 선택적 혹은 필수 프로퍼티 n을 가지는 타입으로 좁히고, "false"분기에서는 선택적 혹은 누락된 프로퍼티 n을 가지는 타입으로  
  좁혀진다.
  
```typeScript
function move(pet: Fish | Bird) {
    if ("swim" in pet) {
        return pet.swim();
    }
    
    return pet.fly();
}
```


***


#### typeof 타입 가드 ( typeof type guards )

- 돌아와서 유니언 타입을 사용하는 버전의 코드를 작성, 타입 서술어를 사용해서 작성할 수 있다.

```typeScript
function isNumber(x: any): x is number {
    return typeof x === "number";
}

function isString(x: any): x is string {
    return typeof x === "string";
}

function padLeft(value: string, padding: string | number) {
    if (isNumber(padding)) {
        return Array(padding + 1).join(" ") + value;
    }
    if (isString(padding)) {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```
> 타입이 원시값인지 확인하는것이 너무 귀찮다.


- 타입스크립트는 typeof 를 사용하여 이를 해결할 수 있다.

```typeScript
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```

- 타입 가드는 두가지 다른 형식인 typeof v === "typename" 과 typeof v !=== "typename" 이 있다.  
  여기서 typename 은 "number, string, boolean, symbol" 이어야 하며, 타입스크립트에서는 위에 없는  
  다른 문자열과 비교하는 것을 막지는 않지만, 타입 가드의 표현식으로 인지되지는 않는다.
